# Prep Package Schema & Integration Spec

Schema definition for `prep-package.json` and integration points with the parallel-dev-cycle skill.

## File Location

```
{projectRoot}/.workflow/.cycle/prep-package.json
```

Generated by: `/prompts:prep-cycle` (interactive prompt)
Consumed by: Phase 1 (Session Initialization)

## JSON Schema

```json
{
  "version": "1.0.0",
  "generated_at": "ISO8601",
  "prep_status": "ready | needs_refinement | blocked",

  "environment": {
    "project_root": "/path/to/project",
    "prerequisites": {
      "required_passed": true,
      "recommended_passed": true,
      "warnings": ["string"]
    },
    "tech_stack": "string (e.g. Express.js + TypeORM + PostgreSQL)",
    "test_framework": "string (e.g. jest, vitest, pytest)",
    "has_project_tech": true,
    "has_project_guidelines": true
  },

  "task": {
    "original": "raw user input",
    "refined": "enhanced task description with all 5 dimensions",
    "quality_score": 8,
    "dimensions": {
      "objective": { "score": 2, "value": "..." },
      "success_criteria": { "score": 2, "value": "..." },
      "scope": { "score": 2, "value": "..." },
      "constraints": { "score": 1, "value": "..." },
      "context": { "score": 1, "value": "..." }
    },
    "source_refs": [
      {
        "path": "docs/prd.md",
        "type": "local_file | url | auto_detected",
        "status": "verified | linked | not_found",
        "preview": "first ~20 lines (local_file only)"
      }
    ]
  },

  "auto_iteration": {
    "enabled": true,
    "no_confirmation": true,
    "max_iterations": 5,
    "timeout_per_iteration_ms": 1800000,
    "convergence": {
      "test_pass_rate": 90,
      "coverage": 80,
      "max_critical_bugs": 0,
      "max_open_issues": 3
    },
    "phase_gates": {
      "zero_to_one": {
        "iterations": [1, 2],
        "exit_criteria": {
          "code_compiles": true,
          "core_test_passes": true,
          "min_requirements_implemented": 1
        }
      },
      "one_to_hundred": {
        "iterations": [3, 4, 5],
        "exit_criteria": {
          "test_pass_rate": 90,
          "coverage": 80,
          "critical_bugs": 0
        }
      }
    },
    "agent_focus": {
      "zero_to_one": {
        "ra": "core_requirements_only",
        "ep": "minimal_viable_architecture",
        "cd": "happy_path_first",
        "vas": "smoke_tests_only"
      },
      "one_to_hundred": {
        "ra": "full_requirements_with_nfr",
        "ep": "refined_architecture_with_risks",
        "cd": "complete_implementation_with_error_handling",
        "vas": "full_test_suite_with_coverage"
      }
    }
  }
}
```

## Phase 1 Integration (Consume & Check)

Phase 1 对 prep-package.json 执行 **6 项验证**，全部通过才加载，任一失败回退默认行为：

| # | 检查项 | 条件 | 失败处理 |
|---|--------|------|----------|
| 1 | prep_status | `=== "ready"` | 跳过 prep |
| 2 | project_root | 与当前 projectRoot 一致 | 跳过 prep（防错误项目） |
| 3 | quality_score | `>= 6` | 跳过 prep（任务质量不达标） |
| 4 | 时效性 | generated_at 在 24h 以内 | 跳过 prep（可能过期） |
| 5 | 必需字段 | task.refined, convergence, phase_gates, agent_focus 全部存在 | 跳过 prep |
| 6 | 收敛值合法 | test_pass_rate/coverage 为 0-100 的数字 | 跳过 prep |

```javascript
// In 01-session-init.md, Step 1.1:
const prepPath = `${projectRoot}/.workflow/.cycle/prep-package.json`
if (fs.existsSync(prepPath)) {
  const raw = JSON.parse(Read(prepPath))
  const checks = validatePrepPackage(raw, projectRoot)

  if (checks.valid) {
    prepPackage = raw
    task = prepPackage.task.refined
    // Inject into state:
    state.convergence = prepPackage.auto_iteration.convergence
    state.phase_gates = prepPackage.auto_iteration.phase_gates
    state.agent_focus = prepPackage.auto_iteration.agent_focus
    state.max_iterations = prepPackage.auto_iteration.max_iterations
  } else {
    console.warn('Prep package validation failed, using defaults')
    // prepPackage remains null → no convergence/phase_gates/agent_focus
  }
}
```

## Phase 2 Integration (Agent Focus Directives)

```javascript
// Before spawning each agent, append focus directive:
function getAgentFocusDirective(agentName, state) {
  if (!state.phase_gates) return ""
  const iteration = state.current_iteration
  const isZeroToOne = state.phase_gates.zero_to_one.iterations.includes(iteration)
  const focus = isZeroToOne
    ? state.agent_focus.zero_to_one[agentName]
    : state.agent_focus.one_to_hundred[agentName]

  const directives = {
    core_requirements_only: "Focus ONLY on core functional requirements. Skip NFRs and edge cases.",
    minimal_viable_architecture: "Design the simplest working architecture. Skip optimization.",
    happy_path_first: "Implement ONLY the happy path. Skip error handling and edge cases.",
    smoke_tests_only: "Run smoke tests only. Skip coverage analysis and exhaustive validation.",
    full_requirements_with_nfr: "Complete requirements including NFRs, edge cases, security.",
    refined_architecture_with_risks: "Refine architecture with risk mitigation and scalability.",
    complete_implementation_with_error_handling: "Complete all tasks with error handling and validation.",
    full_test_suite_with_coverage: "Full test suite with coverage report and quality audit."
  }
  return `\n## FOCUS DIRECTIVE (${isZeroToOne ? '0→1' : '1→100'})\n${directives[focus] || ''}\n`
}
```

## Phase 3 Integration (Convergence Evaluation)

```javascript
// In 03-result-aggregation.md, Step 3.4:
function evaluateConvergence(parsedResults, state) {
  if (!state.phase_gates) {
    // No prep package: use default issue detection
    return { converged: !parsedResults.vas.issues?.length, phase: "default" }
  }
  const iteration = state.current_iteration
  const isZeroToOne = state.phase_gates.zero_to_one.iterations.includes(iteration)

  if (isZeroToOne) {
    return {
      converged: parsedResults.cd.status !== 'failed'
                 && (parsedResults.vas.test_pass_rate > 0 || parsedResults.cd.tests_passing),
      phase: "0→1"
    }
  }
  const conv = state.convergence
  return {
    converged: (parsedResults.vas.test_pass_rate || 0) >= conv.test_pass_rate
               && (parsedResults.vas.coverage || 0) >= conv.coverage
               && (parsedResults.vas.critical_issues || 0) <= conv.max_critical_bugs,
    phase: "1→100"
  }
}
```
